# 知识表示与专家系统

![符号AI内容摘要](../sketchnotes/ai-symbolic.png)

> Sketchnote 由 [Tomomi Imura](https://twitter.com/girlie_mac) 制作

人工智能的追求基于对知识的搜索，旨在使世界的理解方式类似于人类.但你该如何做到这一点呢？

## [课前测验](https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/102)

在AI的早期，创建智能系统的自上而下的方法（在上一课中讨论）很受欢迎.这个想法是将人类的知识提取成某种机器可读的形式，然后用它来自动解决问题.这种方法基于两个重要的概念：

* 知识表示
* 推理

## 知识表示

在符号AI中，一个重要的概念是**知识**.将知识与*信息*或*数据*区分开是很重要的.例如，可以说书籍包含知识，因为你可以通过学习书籍成为专家.然而，书籍中实际包含的是*数据*，通过阅读书籍并将这些数据整合到我们的世界模型中，我们将这些数据转化为知识.

> ✅ **知识**是存储在我们头脑中的东西，代表我们对世界的理解.它通过主动的**学习**过程获得，将我们接收到的信息片段整合到我们对世界的主动模型中.

通常，我们不会严格定义知识，而是使用[DIKW金字塔](https://en.wikipedia.org/wiki/DIKW_pyramid)将其与其他相关概念对齐.它包含以下概念：

* **数据**是以物理媒介表示的东西，例如书面文字或口语.数据独立于人类存在，可以在人与人之间传递.
* **信息**是我们在头脑中对数据的解释.例如，当我们听到“计算机”这个词时，我们对它有一些理解.
* **知识**是将信息整合到我们的世界模型中.例如，一旦我们了解了计算机是什么，我们就开始对它的工作原理、成本以及用途有一些想法.这个相互关联的概念网络形成了我们的知识.
* **智慧**是我们对世界理解的更高层次，代表*元知识*，例如关于如何以及何时使用知识的一些概念.

<img src="images/DIKW_Pyramid.png" width="30%"/>

*图片来自 [维基百科](https://commons.wikimedia.org/w/index.php?curid=37705247)，作者 Longlivetheux - 自创，CC BY-SA 4.0*

因此，**知识表示**的问题是找到一种有效的方法，将知识以数据的形式表示在计算机内部，使其能够自动使用.这可以被看作是一个光谱：

![知识表示光谱](images/knowledge-spectrum.png)

> 图片由 [Dmitry Soshnikov](http://soshnikov.com) 提供

* 在左侧，有非常简单的知识表示类型，计算机可以有效地使用.最简单的是算法表示，当知识由计算机程序表示时.然而，这不是表示知识的最佳方式，因为它不够灵活.我们头脑中的知识往往是非算法的.
* 在右侧，有诸如自然文本的表示.这是最强大的，但无法用于自动推理.

> ✅ 想一想你如何在头脑中表示知识并将其转化为笔记.有没有一种特定的格式对你有助于记忆？

## 计算机知识表示的分类

我们可以将不同的计算机知识表示方法分类如下：

* **网络表示**基于我们头脑中有一个相互关联的概念网络.我们可以尝试在计算机内部以图的形式再现同样的网络 - 所谓的**语义网络**.

1. **对象-属性-值三元组**或**属性-值对**.由于图可以在计算机内部表示为节点和边的列表，我们可以通过包含对象、属性和值的三元组列表来表示语义网络.例如，我们构建以下关于编程语言的三元组：

| 对象    | 属性        | 值                |
| ------- | ----------- | ----------------- |
| Python  | 是          | 无类型语言         |
| Python  | 发明者      | Guido van Rossum  |
| Python  | 语法块      | 缩进               |
| 无类型语言 | 不具备      | 类型定义           |

> ✅ 思考一下三元组如何用于表示其他类型的知识.

2. **层次表示**强调我们经常在头脑中创建对象的层次结构.例如，我们知道金丝雀是一种鸟，所有鸟都有翅膀.我们还对金丝雀通常是什么颜色以及它们的飞行速度有一些了解.

   - **框架表示**基于将每个对象或对象类表示为包含**槽位**的**框架**.槽位可以有默认值、值限制或存储的过程，可以调用以获取槽位的值.所有框架形成一个类似于面向对象编程语言中对象层次结构的层次结构.
   - **场景**是框架的特殊类型，表示可以随时间展开的复杂情况.

**Python**

| 槽位           | 值           | 默认值       | 区间            |
| -------------- | ------------ | ------------ | --------------- |
| 名称           | Python       |              |                 |
| 类型           | 无类型语言   |              |                 |
| 变量命名方式   |              | CamelCase   |                 |
| 程序长度       |              |              | 5-5000 行        |
| 语法块         | 缩进         |              |                 |

3. **过程表示**基于通过一系列动作来表示知识，当某个条件发生时可以执行这些动作.

   - 生产规则是如果-那么语句，允许我们得出结论.例如，医生可以有一个规则，**如果**患者有高烧 **或**血液测试中C反应蛋白水平高 **那么**他有炎症.一旦遇到其中一个条件，我们就可以得出关于炎症的结论，然后在进一步推理中使用它.
   - 算法可以被视为另一种形式的过程表示，尽管它们在基于知识的系统中几乎从不直接使用.

4. **逻辑**最初由亚里士多德提出，作为表示人类普遍知识的一种方式.

   - 谓词逻辑作为一种数学理论过于丰富，无法计算，因此通常使用其子集，如在Prolog中使用的Horn子句.
   - 描述逻辑是一类用于表示和推理对象层次结构的逻辑系统，分布式知识表示如*语义网*.

## 专家系统

符号AI的早期成功之一是所谓的**专家系统** - 旨在在某些有限问题领域充当专家的计算机系统.它们基于从一个或多个人类专家中提取的**知识库**，并包含执行一些推理的**推理引擎**.

![人类架构](images/arch-human.png) | ![基于知识的系统](images/arch-kbs.png)
---------------------------------------------|------------------------------------------------
人类神经系统的简化结构 | 基于知识的系统架构

专家系统的构建方式类似于人类的推理系统，它包含**短期记忆**和**长期记忆**.同样，在基于知识的系统中，我们区分以下组件：

* **问题记忆**：包含当前正在解决的问题的知识，例如患者的体温或血压，他是否有炎症等.这些知识也被称为**静态知识**，因为它包含了我们当前对问题的了解的快照 - 即所谓的*问题状态*.
* **知识库**：表示关于问题领域的长期知识.它由人类专家手动提取，并且在每次咨询之间不会改变.因为它允许我们从一个问题状态导航到另一个问题状态，所以也被称为**动态知识**.
* **推理引擎**：协调整个在问题状态空间中搜索的过程，必要时向用户提问.它还负责找到适用于每个状态的正确规则.

例如，考虑以下根据动物的物理特征确定动物的专家系统：

![AND-OR 树](images/AND-OR-Tree.png)

> 图像由 [Dmitry Soshnikov](http://soshnikov.com) 提供

这个图表被称为**AND-OR 树**，它是生产规则集的图形表示.在开始从专家中提取知识时，绘制树形图是有用的.为了在计算机内部表示知识，使用规则更方便：

```
如果动物吃肉
或者（动物有尖锐的牙齿
    并且动物有爪子
    并且动物有向前看的眼睛）
那么动物是食肉动物
```

您可以注意到规则左侧的每个条件和动作基本上是对象-属性-值（OAV）三元组.**工作记忆**包含与当前正在解决的问题对应的OAV三元组集合.**规则引擎**查找条件满足的规则并应用它们，将另一个三元组添加到工作记忆中.

> ✅ 写下你喜欢主题的自己的AND-OR树！

### 前向推理与后向推理

上述过程称为**前向推理**.它从工作记忆中一些初始的关于问题的数据开始，然后执行以下推理循环：

1. 如果目标属性存在于工作记忆中 - 停止并给出结果
2. 查找所有当前条件满足的规则 - 获得**冲突集**
3. 执行**冲突解决** - 选择一个将在此步骤中执行的规则.可能有不同的冲突解决策略：
   - 选择知识库中第一个适用的规则
   - 选择一个随机规则
   - 选择一个*更具体*的规则，即满足“左侧”（LHS）中最多条件的规则
4. 应用选定的规则并将新的知识片段插入问题状态
5. 重复步骤1

然而，在某些情况下，我们可能想从对问题没有任何知识开始，并提出有助于我们得出结论的问题.例如，在进行医疗诊断时，我们通常不会在开始诊断患者之前进行所有医学分析.我们更倾向于在需要做出决策时进行分析.

这个过程可以使用**后向推理**来建模.它由**目标**驱动 - 我们希望找到的属性值：

1. 选择所有可以给出目标值的规则（即目标在规则的右侧（"RHS"））
2. 如果没有该属性的规则，或者有一条规则说我们应该从用户那里询问该值 - 则询问，否则：
3. 使用冲突解决策略选择一条规则作为*假设* - 我们将尝试证明它
4. 对规则的所有左侧属性递归地重复该过程，尝试将它们作为目标来证明
5. 如果在任何时候该过程失败 - 使用步骤3中的另一条规则

> ✅ 在哪些情况下前向推理更合适？后向推理又如何？

### 实现专家系统

专家系统可以使用不同的工具来实现：

* 直接用某种高级编程语言编写.这不是一个好主意，因为基于知识的系统的主要优势在于知识与推理分离，并且潜在的问题领域专家应该能够编写规则而无需了解推理过程的细节.
* 使用**专家系统外壳**，即专门设计用于使用某种知识表示语言填充知识的系统.

## ✍️ 练习：动物推理

参见 [Animals.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/Animals.ipynb) 了解如何实现前向和后向推理专家系统的示例.

> **注意**：这个示例相当简单，仅仅展示了专家系统的外观.一旦你开始创建这样的系统，直到你达到一定数量的规则（大约200条以上）时，你才会注意到它表现出一些*智能*行为.在某个时点，规则变得过于复杂，无法全部记住，此时你可能会开始质疑系统为何做出某些决定.然而，基于知识的系统的重要特性是你总是可以*解释*任何决策是如何做出的.

## 本体与语义网

在20世纪末，有一项倡议试图使用知识表示来注释互联网资源，以便能够找到符合非常特定查询的资源.这一运动被称为**语义网**，它依赖于几个概念：

- 基于**[描述逻辑](https://en.wikipedia.org/wiki/Description_logic)**（DL）的特殊知识表示.它类似于框架知识表示，因为它构建了具有属性的对象层次结构，但具有正式的逻辑语义和推理.描述逻辑的整个家族在表达能力和推理的算法复杂性之间取得了平衡.
- 分布式知识表示，其中所有概念都由全局URI标识符表示，使得创建跨互联网的知识层次结构成为可能.
- 用于知识描述的一系列基于XML的语言：RDF（资源描述框架）、RDFS（RDF模式）、OWL（本体网语言）.

语义网的核心概念是**本体**.它指的是使用某种形式知识表示对问题领域的明确规范.最简单的本体可以只是问题领域中对象的层次结构，但更复杂的本体将包括可用于推理的规则.

在语义网中，所有表示都基于三元组.每个对象和每个关系都由URI唯一标识.例如，如果我们想要陈述这个AI课程计划是由Dmitry Soshnikov在2022年1月1日开发的，我们可以使用以下三元组：

<img src="images/triplet.png" width="30%"/>

```
http://github.com/microsoft/ai-for-beginners http://www.example.com/terms/creation-date “2022年1月13日”
http://github.com/microsoft/ai-for-beginners http://purl.org/dc/elements/1.1/creator http://soshnikov.com
```

> ✅ 这里 `http://www.example.com/terms/creation-date` 和 `http://purl.org/dc/elements/1.1/creator` 是一些知名且普遍接受的URI，用于表达*创建者*和*创建日期*的概念.

在更复杂的情况下，如果我们想要定义一个创建者列表，可以使用RDF中定义的一些数据结构.

<img src="images/triplet-complex.png" width="40%"/>

> 上述图表由 [Dmitry Soshnikov](http://soshnikov.com) 提供

构建语义网的进展在某种程度上被搜索引擎和自然语言处理技术的成功所放缓，这些技术允许从文本中提取结构化数据.然而，在某些领域，仍然有显著的努力来维护本体和知识库.几个值得注意的项目：

* [WikiData](https://wikidata.org/) 是与维基百科相关联的机器可读知识库的集合.大部分数据来自维基百科页面内的*信息框*，这些是维基百科页面内的结构化内容.你可以使用SPARQL（一种用于语义网的特殊查询语言）[查询](https://query.wikidata.org/) WikiData.以下是一个显示人类最常见眼睛颜色的示例查询：

```sparql
#defaultView:BubbleChart
SELECT ?eyeColorLabel (COUNT(?human) AS ?count)
WHERE
{
  ?human wdt:P31 wd:Q5.       # 人类实例为智人
  ?human wdt:P1340 ?eyeColor. # 人类眼睛颜色是 ?eyeColor
  SERVICE wikibase:label { bd:serviceParam wikibase:language "zh". }
}
GROUP BY ?eyeColorLabel
```

* [DBpedia](https://www.dbpedia.org/) 是另一个类似于WikiData的努力.

> ✅ 如果你想尝试构建自己的本体或打开现有的本体，有一个很棒的可视化本体编辑器，叫做[Protégé](https://protege.stanford.edu/).下载它，或者在线使用.

<img src="images/protege.png" width="70%"/>

*网页Protégé编辑器打开罗曼诺夫家族本体.Dmitry Soshnikov截图*

## ✍️ 练习：家庭本体

参见 [FamilyOntology.ipynb](https://github.com/Ezana135/AI-For-Beginners/blob/main/lessons/2-Symbolic/FamilyOntology.ipynb) 了解如何使用语义网技术推理家庭关系的示例.我们将使用常见GEDCOM格式表示的家谱和家庭关系本体，构建给定个体的所有家庭关系图.

## 微软概念图

在大多数情况下，本体是由人工精心创建的.然而，也可以**挖掘**来自非结构化数据的本体，例如来自自然语言文本的数据.

微软研究院进行了这样的尝试，结果是[微软概念图](https://blogs.microsoft.com/ai/microsoft-researchers-release-graph-that-helps-machines-conceptualize/?WT.mc_id=academic-77998-cacaste).

它是一个大型实体集合，使用`is-a`继承关系分组.它允许回答诸如“微软是什么？”这样的问题 - 答案可能是“一个公司，概率0.87”，以及“一个品牌，概率0.75”.

该图可以作为REST API使用，或作为一个大型可下载的文本文件，列出所有实体对.

## ✍️ 练习：概念图

尝试使用 [MSConceptGraph.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/MSConceptGraph.ipynb) 笔记本，了解如何使用微软概念图将新闻文章分组到几个类别中.

## 结论

如今，AI通常被视为*机器学习*或*神经网络*的同义词.然而，人类也表现出明确的推理，这是当前神经网络尚未处理的.在现实世界的项目中，明确的推理仍然被用于执行需要解释或能够以受控方式修改系统行为的任务.

## 🚀 挑战

在与本课相关的家庭本体笔记本中，有机会尝试其他家庭关系.尝试发现家谱中人物之间的新连接.

## [课后测验](https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/202)

## 复习与自学

在互联网进行一些研究，发现人类在哪些领域尝试量化和编纂知识.了解布鲁姆的分类法，并回顾历史，了解人类如何尝试理解他们的世界.探索林奈（Linnaeus）创建生物分类法的工作，观察德米特里·门捷列夫（Dmitri Mendeleev）如何描述和分组化学元素.你还能找到哪些有趣的例子？

**作业**: [构建一个本体](assignment.md)